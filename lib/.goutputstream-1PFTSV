/*
	ForceGraph.js
	Subclass of Graph. Force directed graph visualization
*/

function ForceGraph(){
	Graph.call(this);
};

ForceGraph.prototype = Graph.prototype;

ForceGraph.springrest=25;
ForceGraph.springconstant=0.0001;

ForceGraph.prototype.scatterNodes=function(width,height){
	for(node in this.nodes){
		this.nodes[node].position.x=Math.random()*width;
		this.nodes[node].position.y=Math.random()*height;
	}
};

//update node position based on force directed algorithm
ForceGraph.prototype.timestep = function(dt){
	//update each node position
	for(key in this.nodes){
		var that=this;
		var node=this.nodes[key];
		//function defining the net acceleration for the current node "that" at a given position and velocity
		function netAcceleration(p,v,dt){
			var damping = 0.005;
			var netforce=new Vector(0,0,0);
			//calculate net force
			for(key in that.edges){
				var origin = that.edges[key].origin;
				var destination = that.edges[key].destination;
				if(origin!=destination && (origin==node || destination==node)){
					//add force caused by edge
					var n2=(origin==node)?destination:origin;
					var springlength = (p.minus(n2.position)).norm();
					var springdisplacement = (springlength-ForceGraph.springrest)/2.0;
					var fr = Physics.hooke(ForceGraph.springconstant,springdisplacement);
					var unitv = n2.position.minus(p).division(-springlength);
					netforce = netforce.add(unitv.product(fr));
				}
			}
			for(key in that.nodes){
				if(key!=node){
					//add force caused by node
					
				}
			}
			//obtain and return net acceleration of the node by divind the net force with its mass
			return new Vector(netforce.x/node.mass-damping*node.velocity.x, netforce.y/node.mass-damping*node.velocity.y, netforce.z/node.mass-damping*node.velocity.z);
		};

		//calculate and update final position and velocity with rungekutta method
		var aprox = Physics.rk4o_3d(node.position,node.velocity,netAcceleration,dt);
		node.position = aprox.position;
		node.velocity = aprox.velocity;
	}
};
